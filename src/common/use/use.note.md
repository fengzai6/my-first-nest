# NestJS 请求生命周期：中间件、守卫、拦截器

在 NestJS 中，理解请求处理的生命周期以及各个组件（如中间件、守卫、拦截器）的执行顺序至关重要。

## 执行顺序

一个典型的请求会按照以下顺序通过各个组件：

1.  **中间件 (Middleware)**
2.  **守卫 (Guards)**
3.  **拦截器 (Interceptors) - 前置处理**
4.  **管道 (Pipes)**
5.  **控制器 (Controller) & 路由处理函数 (Route Handler)**
6.  **拦截器 (Interceptors) - 后置处理 (响应转换)**
7.  **异常过滤器 (Exception Filters)**

## 组件范围和行为

### 中间件 (Middleware)

- **执行时机**: 最先执行。
- **功能**: 可以执行任何代码，对请求和响应对象进行更改，结束请求-响应周期，或调用堆栈中的下一个中间件。
- **范围**:
  - 如果使用 `app.use()` 全局注册，中间件会处理 **所有** 进来的请求，包括像 Swagger UI 这样的静态资源请求。这可能会导致不必要的日志记录或处理。
  - 它不了解 `ExecutionContext`，因此无法像守卫或拦截器那样访问元数据。

### 守卫 (Guards)

- **执行时机**: 在中间件之后，拦截器之前。
- **功能**: 主要负责 **授权**。它们根据特定条件（如角色、权限等）来决定一个给定的请求是否可以被路由处理程序处理。如果守卫返回 `false`，请求将被拒绝。
- **范围**: 绑定到特定的控制器、路由或全局。它们可以访问 `ExecutionContext`，从而获取有关请求的详细信息和通过 `@SetMetadata()` 或自定义装饰器设置的元数据。

### 拦截器 (Interceptors)

- **执行时机**: 包围着路由处理函数的执行。分为前置处理和后置处理。
- **功能**:
  - 在函数执行 **之前** 绑定额外的逻辑。
  - 在函数执行 **之后** 转换从函数返回的结果。
  - 在函数执行 **之后** 转换从函数抛出的异常。
  - 扩展基本函数行为。
  - 完全覆盖一个函数（例如，为了缓存）。
- **范围**: 与守卫类似，它们可以访问 `ExecutionContext`。它们不会处理非 NestJS 路由处理的请求（例如，Swagger 的静态文件服务）。

## 如何更好地控制中间件

全局中间件 (`app.use()`) 的作用范围太广，通常不是最佳选择。为了更精确地控制中间件的应用范围，应该在模块中使用中间件消费者 (`MiddlewareConsumer`)。
